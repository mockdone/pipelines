"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var path = __importStar(require("path"));
var utils_1 = require("./utils");
var artifacts_1 = require("./handlers/artifacts");
exports.BASEPATH = '/pipeline';
exports.apiVersion = 'v1beta1';
exports.apiVersionPrefix = "apis/" + exports.apiVersion;
var Deployments;
(function (Deployments) {
    Deployments["NOT_SPECIFIED"] = "NOT_SPECIFIED";
    Deployments["KUBEFLOW"] = "KUBEFLOW";
    Deployments["MARKETPLACE"] = "MARKETPLACE";
})(Deployments = exports.Deployments || (exports.Deployments = {}));
/** converts string to bool */
var asBool = function (value) { return ['true', '1'].includes(value.toLowerCase()); };
function parseArgs(argv) {
    if (argv.length < 3) {
        var msg = "  Usage: node server.js <static-dir> [port].\n         You can specify the API server address using the\n         ML_PIPELINE_SERVICE_HOST and ML_PIPELINE_SERVICE_PORT\n         env vars.";
        throw new Error(msg);
    }
    var staticDir = path.resolve(argv[2]);
    var port = parseInt(argv[3] || '3000', 10);
    return { staticDir: staticDir, port: port };
}
function loadConfigs(argv, env) {
    var _a = parseArgs(argv), staticDir = _a.staticDir, port = _a.port;
    /** All configurable environment variables can be found here. */
    var 
    /** minio client use these to retrieve minio objects/artifacts */
    _b = env.MINIO_ACCESS_KEY, 
    /** minio client use these to retrieve minio objects/artifacts */
    MINIO_ACCESS_KEY = _b === void 0 ? 'minio' : _b, _c = env.MINIO_SECRET_KEY, MINIO_SECRET_KEY = _c === void 0 ? 'minio123' : _c, _d = env.MINIO_PORT, MINIO_PORT = _d === void 0 ? '9000' : _d, _e = env.MINIO_HOST, MINIO_HOST = _e === void 0 ? 'minio-service' : _e, _f = env.MINIO_NAMESPACE, MINIO_NAMESPACE = _f === void 0 ? 'kubeflow' : _f, _g = env.MINIO_SSL, MINIO_SSL = _g === void 0 ? 'false' : _g, 
    /** minio client use these to retrieve s3 objects/artifacts */
    AWS_ACCESS_KEY_ID = env.AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY = env.AWS_SECRET_ACCESS_KEY, 
    /** http/https base URL */
    _h = env.HTTP_BASE_URL, 
    /** http/https base URL */
    HTTP_BASE_URL = _h === void 0 ? '' : _h, 
    /** http/https fetch with this authorization header key (for example: 'Authorization') */
    _j = env.HTTP_AUTHORIZATION_KEY, 
    /** http/https fetch with this authorization header key (for example: 'Authorization') */
    HTTP_AUTHORIZATION_KEY = _j === void 0 ? '' : _j, 
    /** http/https fetch with this authorization header value by default when absent in client request at above key */
    _k = env.HTTP_AUTHORIZATION_DEFAULT_VALUE, 
    /** http/https fetch with this authorization header value by default when absent in client request at above key */
    HTTP_AUTHORIZATION_DEFAULT_VALUE = _k === void 0 ? '' : _k, 
    /** API service will listen to this host */
    _l = env.ML_PIPELINE_SERVICE_HOST, 
    /** API service will listen to this host */
    ML_PIPELINE_SERVICE_HOST = _l === void 0 ? 'localhost' : _l, 
    /** API service will listen to this port */
    _m = env.ML_PIPELINE_SERVICE_PORT, 
    /** API service will listen to this port */
    ML_PIPELINE_SERVICE_PORT = _m === void 0 ? '3001' : _m, 
    /** path to viewer:tensorboard pod template spec */
    VIEWER_TENSORBOARD_POD_TEMPLATE_SPEC_PATH = env.VIEWER_TENSORBOARD_POD_TEMPLATE_SPEC_PATH, 
    /** Tensorflow image used for tensorboard viewer */
    _o = env.VIEWER_TENSORBOARD_TF_IMAGE_NAME, 
    /** Tensorflow image used for tensorboard viewer */
    VIEWER_TENSORBOARD_TF_IMAGE_NAME = _o === void 0 ? 'tensorflow/tensorflow' : _o, 
    /** Whether custom visualizations are allowed to be generated by the frontend */
    _p = env.ALLOW_CUSTOM_VISUALIZATIONS, 
    /** Whether custom visualizations are allowed to be generated by the frontend */
    ALLOW_CUSTOM_VISUALIZATIONS = _p === void 0 ? 'false' : _p, 
    /** Envoy service will listen to this host */
    _q = env.METADATA_ENVOY_SERVICE_SERVICE_HOST, 
    /** Envoy service will listen to this host */
    METADATA_ENVOY_SERVICE_SERVICE_HOST = _q === void 0 ? 'localhost' : _q, 
    /** Envoy service will listen to this port */
    _r = env.METADATA_ENVOY_SERVICE_SERVICE_PORT, 
    /** Envoy service will listen to this port */
    METADATA_ENVOY_SERVICE_SERVICE_PORT = _r === void 0 ? '9090' : _r, 
    /** Is Argo log archive enabled? */
    _s = env.ARGO_ARCHIVE_LOGS, 
    /** Is Argo log archive enabled? */
    ARGO_ARCHIVE_LOGS = _s === void 0 ? 'false' : _s, 
    /** Use minio or s3 client to retrieve archives. */
    _t = env.ARGO_ARCHIVE_ARTIFACTORY, 
    /** Use minio or s3 client to retrieve archives. */
    ARGO_ARCHIVE_ARTIFACTORY = _t === void 0 ? 'minio' : _t, 
    /** Bucket to retrive logs from */
    _u = env.ARGO_ARCHIVE_BUCKETNAME, 
    /** Bucket to retrive logs from */
    ARGO_ARCHIVE_BUCKETNAME = _u === void 0 ? 'mlpipeline' : _u, 
    /** Prefix to logs. */
    _v = env.ARGO_ARCHIVE_PREFIX, 
    /** Prefix to logs. */
    ARGO_ARCHIVE_PREFIX = _v === void 0 ? 'logs' : _v, 
    /** Disables GKE metadata endpoint. */
    _w = env.DISABLE_GKE_METADATA, 
    /** Disables GKE metadata endpoint. */
    DISABLE_GKE_METADATA = _w === void 0 ? 'false' : _w, 
    /** Enable authorization checks for multi user mode. */
    _x = env.ENABLE_AUTHZ, 
    /** Enable authorization checks for multi user mode. */
    ENABLE_AUTHZ = _x === void 0 ? 'false' : _x, 
    /** Deployment type. */
    _y = env.DEPLOYMENT, 
    /** Deployment type. */
    DEPLOYMENT_STR = _y === void 0 ? '' : _y, 
    /**
     * A header user requests have when authenticated. It carries user identity information.
     * The default value works with Google Cloud IAP.
     */
    _z = env.KUBEFLOW_USERID_HEADER, 
    /**
     * A header user requests have when authenticated. It carries user identity information.
     * The default value works with Google Cloud IAP.
     */
    KUBEFLOW_USERID_HEADER = _z === void 0 ? 'x-goog-authenticated-user-email' : _z, 
    /**
     * KUBEFLOW_USERID_HEADER's value may have a prefix before user identity.
     * Use this header to specify what the prefix is.
     *
     * e.g. a valid header value for default values can be like `accounts.google.com:user@gmail.com`.
     */
    _0 = env.KUBEFLOW_USERID_PREFIX, 
    /**
     * KUBEFLOW_USERID_HEADER's value may have a prefix before user identity.
     * Use this header to specify what the prefix is.
     *
     * e.g. a valid header value for default values can be like `accounts.google.com:user@gmail.com`.
     */
    KUBEFLOW_USERID_PREFIX = _0 === void 0 ? 'accounts.google.com:' : _0;
    return {
        argo: {
            archiveArtifactory: ARGO_ARCHIVE_ARTIFACTORY,
            archiveBucketName: ARGO_ARCHIVE_BUCKETNAME,
            archiveLogs: asBool(ARGO_ARCHIVE_LOGS),
            archivePrefix: ARGO_ARCHIVE_PREFIX,
        },
        artifacts: {
            aws: {
                accessKey: AWS_ACCESS_KEY_ID || '',
                endPoint: 's3.amazonaws.com',
                secretKey: AWS_SECRET_ACCESS_KEY || '',
            },
            http: {
                auth: {
                    defaultValue: HTTP_AUTHORIZATION_DEFAULT_VALUE,
                    key: HTTP_AUTHORIZATION_KEY,
                },
                baseUrl: HTTP_BASE_URL,
            },
            minio: {
                accessKey: MINIO_ACCESS_KEY,
                endPoint: MINIO_NAMESPACE && MINIO_NAMESPACE.length > 0
                    ? MINIO_HOST + "." + MINIO_NAMESPACE
                    : MINIO_HOST,
                port: parseInt(MINIO_PORT, 10),
                secretKey: MINIO_SECRET_KEY,
                useSSL: asBool(MINIO_SSL),
            },
            proxy: artifacts_1.loadArtifactsProxyConfig(env),
        },
        metadata: {
            envoyService: {
                host: METADATA_ENVOY_SERVICE_SERVICE_HOST,
                port: METADATA_ENVOY_SERVICE_SERVICE_PORT,
            },
        },
        pipeline: {
            host: ML_PIPELINE_SERVICE_HOST,
            port: ML_PIPELINE_SERVICE_PORT,
        },
        server: {
            apiVersionPrefix: exports.apiVersionPrefix,
            basePath: exports.BASEPATH,
            deployment: DEPLOYMENT_STR.toUpperCase() === Deployments.KUBEFLOW
                ? Deployments.KUBEFLOW
                : DEPLOYMENT_STR.toUpperCase() === Deployments.MARKETPLACE
                    ? Deployments.MARKETPLACE
                    : Deployments.NOT_SPECIFIED,
            port: port,
            staticDir: staticDir,
        },
        viewer: {
            tensorboard: {
                podTemplateSpec: utils_1.loadJSON(VIEWER_TENSORBOARD_POD_TEMPLATE_SPEC_PATH),
                tfImageName: VIEWER_TENSORBOARD_TF_IMAGE_NAME,
            },
        },
        visualizations: {
            allowCustomVisualizations: asBool(ALLOW_CUSTOM_VISUALIZATIONS),
        },
        gkeMetadata: {
            disabled: asBool(DISABLE_GKE_METADATA),
        },
        auth: {
            enabled: asBool(ENABLE_AUTHZ),
            kubeflowUserIdHeader: KUBEFLOW_USERID_HEADER,
            kubeflowUserIdPrefix: KUBEFLOW_USERID_PREFIX,
        },
    };
}
exports.loadConfigs = loadConfigs;
//# sourceMappingURL=configs.js.map